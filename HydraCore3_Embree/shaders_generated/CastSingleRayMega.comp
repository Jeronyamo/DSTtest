#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_nonuniform_qualifier : require

#include "common_generated.h"

layout(binding = 0, set = 0) buffer data0 { uint out_color[]; }; //
layout(binding = 1, set = 0) buffer data1 { uint m_packedXY[]; }; //
layout(binding = 2, set = 0) buffer data2 { uint m_matIdByPrimId[]; }; //
layout(binding = 3, set = 0) buffer data3 { uint m_matIdOffsets[]; }; //
layout(binding = 4, set = 0) uniform accelerationStructureEXT m_pAccelStruct;
layout(binding = 5, set = 0) uniform sampler2D m_textures[]; //
layout(binding = 6, set = 0) buffer data6 { GLTFMaterial m_materials[]; }; //
layout(binding = 7, set = 0) buffer dataUBO { Integrator_UBO_Data ubo; };

bool isDeadRay(uint a_flags) { return (a_flags & RAY_FLAG_IS_DEAD) != 0; }

BsdfSample MaterialSampleAndEval(int a_materialId, vec4 rands, vec3 v, vec3 n, vec2 tc) {
  const vec2 texCoordT = mulRows2x4(m_materials[a_materialId].row0[0], m_materials[a_materialId].row1[0], tc);
  const vec3 texColor = (texture(m_textures[ m_materials[a_materialId].texId[0] ], texCoordT)).xyz;

  const uint   type      = m_materials[a_materialId].brdfType;
  const vec3 color = m_materials[a_materialId].baseColor.xyz*texColor;
  const vec3 specular = m_materials[a_materialId].metalColor.xyz;
  const vec3 coat = m_materials[a_materialId].coatColor.xyz;
  const float  roughness = 1.0f - m_materials[a_materialId].glosiness;
  float  alpha           = m_materials[a_materialId].alpha;
  
  // TODO: read color     from texture
  // TODO: read roughness from texture
  // TODO: read alpha     from texture

  // TODO: check if glosiness in 1 (roughness is 0), use special case mirror brdf
  //if(roughness == 0.0f && type == BRDF_TYPE_GGX)
  //  type = BRDF_TYPE_MIRROR;

  BsdfSample res;
  switch(type)
  {
    case BRDF_TYPE_GLTF:
    case BRDF_TYPE_GGX:
    case BRDF_TYPE_LAMBERT:
    default:
    {
      const vec3 ggxDir = ggxSample(vec2(rands.x,rands.y), v, n, roughness);
      const float  ggxPdf = ggxEvalPDF (ggxDir, v, n, roughness); 
      const float  ggxVal = ggxEvalBSDF(ggxDir, v, n, roughness);
      
      const vec3 lambertDir = lambertSample(vec2(rands.x,rands.y), v, n);
      const float  lambertPdf = lambertEvalPDF(lambertDir, v, n);
      const float  lambertVal = lambertEvalBSDF(lambertDir, v, n);

      const vec3 h = normalize(v - ggxDir); // half vector.
    
      if(type == BRDF_TYPE_GGX)
        alpha = 1.0f;

      // (1) select between metal and dielectric via rands.z
      //
      float pdfSelect = 1.0f;
      if(rands.z < alpha) // select metall
      {
        pdfSelect *= alpha;
        const vec3 F = gltfConductorFresnel(specular, dot(h,v));
        res.direction = ggxDir;
        res.color     = ggxVal*F*alpha;
        res.pdf       = ggxPdf;
      }
      else                // select dielectric
      {
        pdfSelect *= 1.0f - alpha;
        
        // (2) now select between specular and diffise via rands.w
        //
        float fDielectric = gltfFresnelMix2(dot(h,v));
        if(type == BRDF_TYPE_LAMBERT)
          fDielectric = 0.0f;

        if(rands.w < fDielectric) // specular
        {
          pdfSelect *= fDielectric;
          res.direction = ggxDir;
          res.color     = ggxVal*coat*fDielectric*(1.0f - alpha);
          res.pdf       = ggxPdf;
        } 
        else
        {
          pdfSelect *= (1.0f-fDielectric); // lambert
          res.direction = lambertDir;
          res.color     = lambertVal*color*(1.0f-fDielectric)*(1.0f - alpha);
          res.pdf       = lambertPdf;
        }
      }
      
      res.pdf *= pdfSelect;
      res.flags = int(RAY_FLAG_HAS_NON_SPEC);
    }
    break;
    case BRDF_TYPE_MIRROR:
    {
      res.direction = reflect(v, n);
      // BSDF is multiplied (outside) by cosThetaOut.
      // For mirrors this shouldn't be done, so we pre-divide here instead.
      //
      const float cosThetaOut = dot(res.direction, n);
      res.color     = specular*(1.0f/max(cosThetaOut, 1e-6f));
      res.pdf       = 1.0f;
      res.flags     = 0;
    }
    break;
  }

  return res;
}

uint packMatId(uint a_flags, uint a_matId) { return (a_flags & 0xFF000000) | (a_matId & 0x00FFFFFF); }

float LightEvalPDF(int a_lightId, vec3 illuminationPoint, vec3 ray_dir, in SurfaceHit pSurfaceHit) {
  const vec3 lpos = pSurfaceHit.pos;
  const vec3 lnorm = pSurfaceHit.norm;
  const float hitDist = length(illuminationPoint - lpos);
  const float pdfA    = 1.0f / (4.0f*ubo.m_light.size.x*ubo.m_light.size.y);
  const float cosVal  = max(dot(ray_dir, -1.0f*lnorm), 0.0f);
  return PdfAtoW(pdfA, hitDist, cosVal);
}

float LightPdfSelectRev(int a_lightId) { 
  return 1.0f; 
}

BsdfEval MaterialEval(int a_materialId, vec3 l, vec3 v, vec3 n, vec2 tc) {
  const vec2 texCoordT = mulRows2x4(m_materials[a_materialId].row0[0], m_materials[a_materialId].row1[0], tc);
  const vec3 texColor = (texture(m_textures[ m_materials[a_materialId].texId[0] ], texCoordT)).xyz;

  const uint type       = m_materials[a_materialId].brdfType;
  const vec3 color = m_materials[a_materialId].baseColor.xyz*texColor;
  const vec3 specular = m_materials[a_materialId].metalColor.xyz;
  const vec3 coat = m_materials[a_materialId].coatColor.xyz;
  const float roughness = 1.0f - m_materials[a_materialId].glosiness;
        float  alpha    = m_materials[a_materialId].alpha;

  // TODO: read color     from texture
  // TODO: read roughness from texture
  // TODO: read alpha     from texture
 
  // TODO: check if glosiness in 1 (roughness is 0), use special case mirror brdf
  //if(roughness == 0.0f && type == BRDF_TYPE_GGX)
  //  type = BRDF_TYPE_MIRROR;


  BsdfEval res;
  switch(type)
  {
    case BRDF_TYPE_GLTF:
    case BRDF_TYPE_GGX:
    case BRDF_TYPE_LAMBERT:
    default:
    {
      if(type == BRDF_TYPE_GGX)
        alpha = 1.0f;
        
      const float ggxVal = ggxEvalBSDF(l, v, n, roughness);
      const float ggxPdf = ggxEvalPDF (l, v, n, roughness);
      
      const float lambertVal = lambertEvalBSDF(l, v, n);
      const float lambertPdf = lambertEvalPDF (l, v, n);
      
      const vec3 h = normalize(v + l);
      const vec3 F = gltfConductorFresnel(specular, dot(h,v));

      const vec3 specularColor = ggxVal*F;                  // (1) eval metal and (same) specular component
      float  fDielectric         = gltfFresnelMix2(dot(h,v)); // (2) eval dielectric component
      if(type == BRDF_TYPE_LAMBERT)
        fDielectric = 0.0f;
      const float  dielectricPdf = (1.0f-fDielectric)*lambertPdf       + fDielectric*ggxPdf;
      const vec3 dielectricVal = (1.0f-fDielectric)*lambertVal*color + fDielectric*ggxVal*coat;

      res.color = alpha*specularColor + (1.0f - alpha)*dielectricVal; // (3) accumulate final color and pdf
      res.pdf   = alpha*ggxPdf        + (1.0f - alpha)*dielectricPdf; // (3) accumulate final color and pdf
    }
    break;
    case BRDF_TYPE_MIRROR:
    {
      res.color = vec3(0,0,0);
      res.pdf   = 0.0f;
    }
    break;
  }
  return res;
}

uint extractMatId(uint a_flags) { return (a_flags & 0x00FFFFFF); }

bool hasNonSpecular(uint a_flags) { return (a_flags & RAY_FLAG_HAS_NON_SPEC) != 0; }

// RayScene intersection with 'm_pAccelStruct'
//
CRT_Hit m_pAccelStruct_RayQuery_NearestHit(const vec4 rayPos, const vec4 rayDir)
{
  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery, m_pAccelStruct, gl_RayFlagsOpaqueEXT, 0xff, rayPos.xyz, rayPos.w, rayDir.xyz, rayDir.w);
  
  while(rayQueryProceedEXT(rayQuery)) { } // actually may omit 'while' when 'gl_RayFlagsOpaqueEXT' is used
 
  CRT_Hit res;
  res.primId = -1;
  res.instId = -1;
  res.geomId = -1;
  res.t      = rayDir.w;

  if(rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
  {    
	  res.primId    = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
	  res.geomId    = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
    res.instId    = rayQueryGetIntersectionInstanceIdEXT    (rayQuery, true);
	  res.t         = rayQueryGetIntersectionTEXT(rayQuery, true);
    vec2 bars     = rayQueryGetIntersectionBarycentricsEXT(rayQuery, true);
    
    res.coords[0] = bars.y;
    res.coords[1] = bars.x;
    res.coords[2] = 1.0f - bars.y - bars.x;
  }

  return res;
}

bool m_pAccelStruct_RayQuery_AnyHit(const vec4 rayPos, const vec4 rayDir)
{
  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery, m_pAccelStruct, gl_RayFlagsTerminateOnFirstHitEXT, 0xff, rayPos.xyz, rayPos.w, rayDir.xyz, rayDir.w);
  rayQueryProceedEXT(rayQuery);
  return (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout( push_constant ) uniform kernelArgs
{
  uint iNumElementsX; 
  uint iNumElementsY; 
  uint iNumElementsZ; 
  uint tFlagsMask;    
} kgenArgs;

///////////////////////////////////////////////////////////////// subkernels here
void kernel_GetRayColor_m_packedXY_out_color(uint tid, in Lite_Hit in_hit, uint in_pakedXYOffset, uint out_colorOffset) 
{
   
  const Lite_Hit lhit = in_hit;
  if(lhit.geomId == -1)
  {
    out_color[tid + out_colorOffset] = 0;
    return;
  }

  const uint matId = m_matIdByPrimId[m_matIdOffsets[lhit.geomId] + uint(lhit.primId)];
  const vec4 mdata = m_materials[matId].baseColor;
  //const float3 color   = mdata.w > 0.0f ? clamp(float3(mdata.w,mdata.w,mdata.w), 0.0f, 1.0f) : to_float3(mdata);
  vec3 temp_color = mdata.w > 0.0f ? clamp(vec3(mdata.w,mdata.w,mdata.w), 0.0f, 1.0f) : mdata.xyz;
  if (lhit.instId == 1 && lhit.primId == 8)
      temp_color = vec3(0.f,0.f,1.f);
  const vec3 color = temp_color;
  const uint XY = m_packedXY[tid + in_pakedXYOffset];
  const uint x  = (XY & 0x0000FFFF);
  const uint y  = (XY & 0xFFFF0000) >> 16;

  out_color[y*uint(ubo.m_winWidth)+x + out_colorOffset] = RealColorToUint32_f3(color);

}

void kernel_InitEyeRay_m_packedXY(uint tid, uint packedXYOffset, inout vec4 rayPosAndNear, inout vec4 rayDirAndFar) 
{
  
  const uint XY = m_packedXY[tid + packedXYOffset];

  const uint x = (XY & 0x0000FFFF);
  const uint y = (XY & 0xFFFF0000) >> 16;

  vec3 rayDir = EyeRayDir(float(x), float(y), float(ubo.m_winWidth), float(ubo.m_winHeight), ubo.m_projInv); 
  vec3 rayPos = vec3(0,0,0);

  transform_ray3f(ubo.m_worldViewInv, 
                  rayPos, rayDir);
  
  rayPosAndNear = vec4(rayPos, 0.0f);
  rayDirAndFar  = vec4(rayDir, MAXFLOAT);

}

bool kernel_RayTrace(uint tid, in vec4 rayPosAndNear, inout vec4 rayDirAndFar, inout Lite_Hit out_hit, inout vec2 out_bars) 
{
  
  const vec4 rayPos = rayPosAndNear;
  const vec4 rayDir = rayDirAndFar ;

 // std::cout << std::endl;
  CRT_Hit hit = m_pAccelStruct_RayQuery_NearestHit(rayPos, rayDir);
  
  Lite_Hit res;
  res.primId = int(hit.primId);
  res.instId = int(hit.instId);
  res.geomId = int(hit.geomId);
  res.t      = hit.t;

  vec2 baricentrics = vec2(hit.coords[0],hit.coords[1]);
 
  out_hit  = res;
  out_bars = baricentrics;
  return (res.primId != -1);

}

///////////////////////////////////////////////////////////////// subkernels here

void main()
{
  ///////////////////////////////////////////////////////////////// prolog
  const uint tid = uint(gl_GlobalInvocationID[0]); 
  ///////////////////////////////////////////////////////////////// prolog

  
  vec4 rayPosAndNear,  rayDirAndFar;
  kernel_InitEyeRay_m_packedXY(tid, 0, rayPosAndNear, rayDirAndFar);

  Lite_Hit hit; 
  vec2 baricentrics; 
  if(!kernel_RayTrace(tid, rayPosAndNear, rayDirAndFar, hit, baricentrics))
    return;
  
  kernel_GetRayColor_m_packedXY_out_color(tid, hit, 0, 0);

}

