#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_nonuniform_qualifier : require

#include "common_generated.h"

layout(binding = 0, set = 0) buffer data0 { vec4 out_color[]; }; //
layout(binding = 1, set = 0) buffer data1 { uint m_packedXY[]; }; //
layout(binding = 2, set = 0) buffer data2 { RandomGenT m_randomGens[]; }; //
layout(binding = 3, set = 0) buffer data3 { uint m_matIdOffsets[]; }; //
layout(binding = 4, set = 0) buffer data4 { mat4 m_normMatrices[]; }; //
layout(binding = 5, set = 0) buffer data5 { uint m_vertOffset[]; }; //
layout(binding = 6, set = 0) buffer data6 { vec4 m_vNorm4f[]; }; //
layout(binding = 7, set = 0) buffer data7 { uint m_matIdByPrimId[]; }; //
layout(binding = 8, set = 0) uniform accelerationStructureEXT m_pAccelStruct;
layout(binding = 9, set = 0) buffer data9 { uint m_triIndices[]; }; //
layout(binding = 10, set = 0) buffer data10 { vec2 m_vTexc2f[]; }; //
layout(binding = 11, set = 0) uniform sampler2D m_textures[]; //
layout(binding = 12, set = 0) buffer data12 { GLTFMaterial m_materials[]; }; //
layout(binding = 13, set = 0) buffer dataUBO { Integrator_UBO_Data ubo; };

bool isDeadRay(uint a_flags) { return (a_flags & RAY_FLAG_IS_DEAD) != 0; }

BsdfSample MaterialSampleAndEval(int a_materialId, vec4 rands, vec3 v, vec3 n, vec2 tc) {
  const vec2 texCoordT = mulRows2x4(m_materials[a_materialId].row0[0], m_materials[a_materialId].row1[0], tc);
  const vec3 texColor = (texture(m_textures[ m_materials[a_materialId].texId[0] ], texCoordT)).xyz;

  const uint   type      = m_materials[a_materialId].brdfType;
  const vec3 color = m_materials[a_materialId].baseColor.xyz*texColor;
  const vec3 specular = m_materials[a_materialId].metalColor.xyz;
  const vec3 coat = m_materials[a_materialId].coatColor.xyz;
  const float  roughness = 1.0f - m_materials[a_materialId].glosiness;
  float  alpha           = m_materials[a_materialId].alpha;
  
  // TODO: read color     from texture
  // TODO: read roughness from texture
  // TODO: read alpha     from texture

  // TODO: check if glosiness in 1 (roughness is 0), use special case mirror brdf
  //if(roughness == 0.0f && type == BRDF_TYPE_GGX)
  //  type = BRDF_TYPE_MIRROR;

  BsdfSample res;
  switch(type)
  {
    case BRDF_TYPE_GLTF:
    case BRDF_TYPE_GGX:
    case BRDF_TYPE_LAMBERT:
    default:
    {
      const vec3 ggxDir = ggxSample(vec2(rands.x,rands.y), v, n, roughness);
      const float  ggxPdf = ggxEvalPDF (ggxDir, v, n, roughness); 
      const float  ggxVal = ggxEvalBSDF(ggxDir, v, n, roughness);
      
      const vec3 lambertDir = lambertSample(vec2(rands.x,rands.y), v, n);
      const float  lambertPdf = lambertEvalPDF(lambertDir, v, n);
      const float  lambertVal = lambertEvalBSDF(lambertDir, v, n);

      const vec3 h = normalize(v - ggxDir); // half vector.
    
      if(type == BRDF_TYPE_GGX)
        alpha = 1.0f;

      // (1) select between metal and dielectric via rands.z
      //
      float pdfSelect = 1.0f;
      if(rands.z < alpha) // select metall
      {
        pdfSelect *= alpha;
        const vec3 F = gltfConductorFresnel(specular, dot(h,v));
        res.direction = ggxDir;
        res.color     = ggxVal*F*alpha;
        res.pdf       = ggxPdf;
      }
      else                // select dielectric
      {
        pdfSelect *= 1.0f - alpha;
        
        // (2) now select between specular and diffise via rands.w
        //
        float fDielectric = gltfFresnelMix2(dot(h,v));
        if(type == BRDF_TYPE_LAMBERT)
          fDielectric = 0.0f;

        if(rands.w < fDielectric) // specular
        {
          pdfSelect *= fDielectric;
          res.direction = ggxDir;
          res.color     = ggxVal*coat*fDielectric*(1.0f - alpha);
          res.pdf       = ggxPdf;
        } 
        else
        {
          pdfSelect *= (1.0f-fDielectric); // lambert
          res.direction = lambertDir;
          res.color     = lambertVal*color*(1.0f-fDielectric)*(1.0f - alpha);
          res.pdf       = lambertPdf;
        }
      }
      
      res.pdf *= pdfSelect;
      res.flags = int(RAY_FLAG_HAS_NON_SPEC);
    }
    break;
    case BRDF_TYPE_MIRROR:
    {
      res.direction = reflect(v, n);
      // BSDF is multiplied (outside) by cosThetaOut.
      // For mirrors this shouldn't be done, so we pre-divide here instead.
      //
      const float cosThetaOut = dot(res.direction, n);
      res.color     = specular*(1.0f/max(cosThetaOut, 1e-6f));
      res.pdf       = 1.0f;
      res.flags     = 0;
    }
    break;
  }

  return res;
}

uint packMatId(uint a_flags, uint a_matId) { return (a_flags & 0xFF000000) | (a_matId & 0x00FFFFFF); }

float LightEvalPDF(int a_lightId, vec3 illuminationPoint, vec3 ray_dir, in SurfaceHit pSurfaceHit) {
  const vec3 lpos = pSurfaceHit.pos;
  const vec3 lnorm = pSurfaceHit.norm;
  const float hitDist = length(illuminationPoint - lpos);
  const float pdfA    = 1.0f / (4.0f*ubo.m_light.size.x*ubo.m_light.size.y);
  const float cosVal  = max(dot(ray_dir, -1.0f*lnorm), 0.0f);
  return PdfAtoW(pdfA, hitDist, cosVal);
}

float LightPdfSelectRev(int a_lightId) { 
  return 1.0f; 
}

BsdfEval MaterialEval(int a_materialId, vec3 l, vec3 v, vec3 n, vec2 tc) {
  const vec2 texCoordT = mulRows2x4(m_materials[a_materialId].row0[0], m_materials[a_materialId].row1[0], tc);
  const vec3 texColor = (texture(m_textures[ m_materials[a_materialId].texId[0] ], texCoordT)).xyz;

  const uint type       = m_materials[a_materialId].brdfType;
  const vec3 color = m_materials[a_materialId].baseColor.xyz*texColor;
  const vec3 specular = m_materials[a_materialId].metalColor.xyz;
  const vec3 coat = m_materials[a_materialId].coatColor.xyz;
  const float roughness = 1.0f - m_materials[a_materialId].glosiness;
        float  alpha    = m_materials[a_materialId].alpha;

  // TODO: read color     from texture
  // TODO: read roughness from texture
  // TODO: read alpha     from texture
 
  // TODO: check if glosiness in 1 (roughness is 0), use special case mirror brdf
  //if(roughness == 0.0f && type == BRDF_TYPE_GGX)
  //  type = BRDF_TYPE_MIRROR;


  BsdfEval res;
  switch(type)
  {
    case BRDF_TYPE_GLTF:
    case BRDF_TYPE_GGX:
    case BRDF_TYPE_LAMBERT:
    default:
    {
      if(type == BRDF_TYPE_GGX)
        alpha = 1.0f;
        
      const float ggxVal = ggxEvalBSDF(l, v, n, roughness);
      const float ggxPdf = ggxEvalPDF (l, v, n, roughness);
      
      const float lambertVal = lambertEvalBSDF(l, v, n);
      const float lambertPdf = lambertEvalPDF (l, v, n);
      
      const vec3 h = normalize(v + l);
      const vec3 F = gltfConductorFresnel(specular, dot(h,v));

      const vec3 specularColor = ggxVal*F;                  // (1) eval metal and (same) specular component
      float  fDielectric         = gltfFresnelMix2(dot(h,v)); // (2) eval dielectric component
      if(type == BRDF_TYPE_LAMBERT)
        fDielectric = 0.0f;
      const float  dielectricPdf = (1.0f-fDielectric)*lambertPdf       + fDielectric*ggxPdf;
      const vec3 dielectricVal = (1.0f-fDielectric)*lambertVal*color + fDielectric*ggxVal*coat;

      res.color = alpha*specularColor + (1.0f - alpha)*dielectricVal; // (3) accumulate final color and pdf
      res.pdf   = alpha*ggxPdf        + (1.0f - alpha)*dielectricPdf; // (3) accumulate final color and pdf
    }
    break;
    case BRDF_TYPE_MIRROR:
    {
      res.color = vec3(0,0,0);
      res.pdf   = 0.0f;
    }
    break;
  }
  return res;
}

uint extractMatId(uint a_flags) { return (a_flags & 0x00FFFFFF); }

bool hasNonSpecular(uint a_flags) { return (a_flags & RAY_FLAG_HAS_NON_SPEC) != 0; }

// RayScene intersection with 'm_pAccelStruct'
//
CRT_Hit m_pAccelStruct_RayQuery_NearestHit(const vec4 rayPos, const vec4 rayDir)
{
  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery, m_pAccelStruct, gl_RayFlagsOpaqueEXT, 0xff, rayPos.xyz, rayPos.w, rayDir.xyz, rayDir.w);
  
  while(rayQueryProceedEXT(rayQuery)) { } // actually may omit 'while' when 'gl_RayFlagsOpaqueEXT' is used
 
  CRT_Hit res;
  res.primId = -1;
  res.instId = -1;
  res.geomId = -1;
  res.t      = rayDir.w;

  if(rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
  {    
	  res.primId    = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
	  res.geomId    = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
    res.instId    = rayQueryGetIntersectionInstanceIdEXT    (rayQuery, true);
	  res.t         = rayQueryGetIntersectionTEXT(rayQuery, true);
    vec2 bars     = rayQueryGetIntersectionBarycentricsEXT(rayQuery, true);
    
    res.coords[0] = bars.y;
    res.coords[1] = bars.x;
    res.coords[2] = 1.0f - bars.y - bars.x;
  }

  return res;
}

bool m_pAccelStruct_RayQuery_AnyHit(const vec4 rayPos, const vec4 rayDir)
{
  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery, m_pAccelStruct, gl_RayFlagsTerminateOnFirstHitEXT, 0xff, rayPos.xyz, rayPos.w, rayDir.xyz, rayDir.w);
  rayQueryProceedEXT(rayQuery);
  return (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout( push_constant ) uniform kernelArgs
{
  uint a_maxDepth;
  uint iNumElementsX; 
  uint iNumElementsY; 
  uint iNumElementsZ; 
  uint tFlagsMask;    
} kgenArgs;

///////////////////////////////////////////////////////////////// subkernels here
void kernel_ContributeToImage_m_packedXY_out_color(uint tid, in vec4 a_accumColor, in RandomGen gen, uint in_pakedXYOffset, uint out_colorOffset) 
{
  
  const uint XY = m_packedXY[tid + in_pakedXYOffset];
  const uint x  = (XY & 0x0000FFFF);
  const uint y  = (XY & 0xFFFF0000) >> 16;
 
  out_color[y*uint(ubo.m_winWidth)+x + out_colorOffset] += a_accumColor;
  m_randomGens[tid] = gen;

}

void kernel_InitEyeRay2_m_packedXY(uint tid, uint packedXYOffset, inout vec4 rayPosAndNear, inout vec4 rayDirAndFar, inout vec4 accumColor, inout vec4 accumuThoroughput, inout RandomGen gen, inout uint rayFlags) 
{
  
  accumColor        = vec4(0, 0, 0, 1);
  accumuThoroughput = vec4(1, 1, 1, 1);
  RandomGen genLocal = m_randomGens[tid];
  rayFlags          = 0;

  const uint XY = m_packedXY[tid + packedXYOffset];

  const uint x = (XY & 0x0000FFFF);
  const uint y = (XY & 0xFFFF0000) >> 16;

  const vec2 pixelOffsets = rndFloat2_Pseudo(genLocal) - vec2(0.5f);
  const float fx = float(x) + pixelOffsets.x;
  const float fy = float(y) + pixelOffsets.y;

  vec3 rayDir = EyeRayDir(fx, fy, float(ubo.m_winWidth), float(ubo.m_winHeight), ubo.m_projInv); 
  vec3 rayPos = vec3(0,0,0);

  transform_ray3f(ubo.m_worldViewInv, rayPos, rayDir);
  
  rayPosAndNear = vec4(rayPos, 0.0f);
  rayDirAndFar  = vec4(rayDir, MAXFLOAT);
  gen           = genLocal;

}

void kernel_SampleLightSource(uint tid, in vec4 rayPosAndNear, in vec4 rayDirAndFar, in vec4 in_hitPart1, in vec4 in_hitPart2, in uint rayFlags, inout RandomGen a_gen, inout vec4 out_shadeColor) 
{
  
  const uint currRayFlags = rayFlags;
  if(isDeadRay(currRayFlags))
    return;
    
  const uint matId = extractMatId(currRayFlags);
  const vec3 ray_dir = rayDirAndFar.xyz;
  
  const vec4 data1 = in_hitPart1;
  const vec4 data2 = in_hitPart2;

  SurfaceHit hit;
  hit.pos  = data1.xyz;
  hit.norm = data2.xyz;
  hit.uv   = vec2(data1.w,data2.w);

  const vec2 uv = rndFloat2_Pseudo(a_gen);
  
  const vec2 sampleOff = 2.0f*(vec2(-0.5f,-0.5f) + uv)*ubo.m_light.size;
  const vec3 samplePos = ubo.m_light.pos.xyz + vec3(sampleOff.x,-1e-5f,sampleOff.y);
  const float  hitDist   = sqrt(dot(hit.pos - samplePos, hit.pos - samplePos));

  const vec3 shadowRayDir = normalize(samplePos - hit.pos); // explicitSam.direction;
  const vec3 shadowRayPos = hit.pos + hit.norm*max(maxcomp(hit.pos), 1.0f)*5e-6f; // TODO: see Ray Tracing Gems

  const bool inShadow = m_pAccelStruct_RayQuery_AnyHit(vec4(shadowRayPos, 0.0f), vec4(shadowRayDir, hitDist*0.9995f));
  
  if(!inShadow && dot(shadowRayDir, ubo.m_light.norm.xyz) < 0.0f)
  {
    const float lightPickProb = 1.0f;
    const float pdfA          = 1.0f / (4.0f*ubo.m_light.size.x*ubo.m_light.size.y);
    const float cosVal        = max(dot(shadowRayDir, (-1.0f)*ubo.m_light.norm.xyz), 0.0f);
    const float lgtPdfW       = PdfAtoW(pdfA, hitDist, cosVal);
    const BsdfEval bsdfV      = MaterialEval(int(matId), shadowRayDir, (-1.0f)*ray_dir, hit.norm, hit.uv);
    const float cosThetaOut   = max(dot(shadowRayDir, hit.norm), 0.0f);

    float misWeight = 1.0f;
    if(ubo.m_intergatorType == INTEGRATOR_MIS_PT)
      misWeight = misWeightHeuristic(lgtPdfW, bsdfV.pdf);

    if(cosVal <= 0.0f)
      out_shadeColor = vec4(0.0f,0.0f,0.0f,0.0f);
    else
      out_shadeColor = vec4((1.0f/lightPickProb)*(ubo.m_light.intensity.xyz*bsdfV.color/lgtPdfW)*cosThetaOut*misWeight, 0.0f);
  }
  else
    out_shadeColor = vec4(0.0f,0.0f,0.0f,1.0f);

}

void kernel_NextBounce(uint tid, uint bounce, in vec4 in_hitPart1, in vec4 in_hitPart2, in vec4 in_shadeColor, inout vec4 rayPosAndNear, inout vec4 rayDirAndFar, inout vec4 accumColor, inout vec4 accumThoroughput, inout RandomGen a_gen, inout MisData misPrev, inout uint rayFlags) 
{
  
  const uint currRayFlags = rayFlags;
  if(isDeadRay(currRayFlags))
    return;
    
  const uint matId = extractMatId(currRayFlags);

  // process surcase hit case
  //
  const vec3 ray_dir = rayDirAndFar.xyz;
  const vec3 ray_pos = rayPosAndNear.xyz;
  
  const vec4 data1 = in_hitPart1;
  const vec4 data2 = in_hitPart2;
  
  SurfaceHit hit;
  hit.pos  = data1.xyz;
  hit.norm = data2.xyz;
  hit.uv   = vec2(data1.w,data2.w);
  
  const MisData prevBounce = misPrev;
  const float   prevPdfW   = prevBounce.matSamplePdf;
  const float   prevPdfA   = (prevPdfW >= 0.0f) ? PdfWtoA(prevPdfW, length(ray_pos - hit.norm), prevBounce.cosTheta) : 1.0f;

  // process light hit case
  //
  if(m_materials[matId].brdfType == BRDF_TYPE_LIGHT_SOURCE)
  {
    const float lightIntensity = m_materials[matId].baseColor.w;
    float misWeight = 1.0f;
    if(ubo.m_intergatorType == INTEGRATOR_MIS_PT) 
    {
      if(bounce > 0)
      {
        const int lightId   = 0; // #TODO: get light id from material info
        const float lgtPdf  = LightPdfSelectRev(lightId)*LightEvalPDF(lightId, ray_pos, ray_dir, hit);
        misWeight           = misWeightHeuristic(prevPdfW, lgtPdf);
        if (prevPdfW <= 0.0f) // specular bounce
          misWeight = 1.0f;
      }
    }
    else if(ubo.m_intergatorType == INTEGRATOR_SHADOW_PT && hasNonSpecular(currRayFlags))
      misWeight = 0.0f;
    
    vec4 currAccumColor = accumColor;
    vec4 currAccumThoroughput = accumThoroughput;
    
    const float lightDirectionAtten = dot(rayDirAndFar.xyz, vec3(0,-1,0)) < 0.0f ? 1.0f : 0.0f;
    
    currAccumColor.x += currAccumThoroughput.x*lightIntensity*misWeight*lightDirectionAtten;
    currAccumColor.y += currAccumThoroughput.y*lightIntensity*misWeight*lightDirectionAtten;
    currAccumColor.z += currAccumThoroughput.z*lightIntensity*misWeight*lightDirectionAtten;
    if(bounce > 0)
      currAccumColor.w *= prevPdfA;
    
    accumColor = currAccumColor;
    rayFlags   = currRayFlags | (RAY_FLAG_IS_DEAD | RAY_FLAG_HIT_LIGHT);
    return;
  }
  
  const vec4 uv = rndFloat4_Pseudo(a_gen);
  const BsdfSample matSam = MaterialSampleAndEval(int(matId), uv, (-1.0f)*ray_dir, hit.norm, hit.uv);
  const vec3 bxdfVal = matSam.color * (1.0f / max(matSam.pdf, 1e-10f));
  const float  cosTheta   = dot(matSam.direction, hit.norm);

  MisData nextBounceData;                   // remember current pdfW for next bounce
  nextBounceData.matSamplePdf = matSam.pdf; //
  nextBounceData.cosTheta     = cosTheta;   //
  misPrev = nextBounceData;                //

  if(ubo.m_intergatorType == INTEGRATOR_STUPID_PT)
  {
    accumThoroughput *= cosTheta*vec4(bxdfVal, 0.0f); 
  }
  else if(ubo.m_intergatorType == INTEGRATOR_SHADOW_PT || ubo.m_intergatorType == INTEGRATOR_MIS_PT)
  {
    const vec4 currThoroughput = accumThoroughput;
    const vec4 shadeColor = in_shadeColor;
    vec4 currAccumColor = accumColor;

    currAccumColor.x += currThoroughput.x * shadeColor.x;
    currAccumColor.y += currThoroughput.y * shadeColor.y;
    currAccumColor.z += currThoroughput.z * shadeColor.z;
    if(bounce > 0)
      currAccumColor.w *= prevPdfA;

    accumColor       = currAccumColor;
    accumThoroughput = currThoroughput*cosTheta*vec4(bxdfVal, 0.0f); 
  }

  rayPosAndNear = vec4(OffsRayPos(hit.pos, hit.norm, matSam.direction), 0.0f);
  rayDirAndFar  = vec4(matSam.direction, MAXFLOAT);
  rayFlags      = currRayFlags | uint(matSam.flags);

}

void kernel_RayTrace2(uint tid, in vec4 rayPosAndNear, in vec4 rayDirAndFar, inout vec4 out_hit1, inout vec4 out_hit2, inout uint rayFlags) 
{
  
  const uint currRayFlags = rayFlags;
  if(isDeadRay(currRayFlags))
    return;
    
  const vec4 rayPos = rayPosAndNear;
  const vec4 rayDir = rayDirAndFar ;

  const CRT_Hit hit   = m_pAccelStruct_RayQuery_NearestHit(rayPos, rayDir);

  if(hit.geomId != uint32_t(-1))
  {
    const vec2 uv = vec2(hit.coords[0],hit.coords[1]);
    const vec3 hitPos = rayPos.xyz + hit.t*rayDir.xyz;

    const uint triOffset  = m_matIdOffsets[hit.geomId];
    const uint vertOffset = m_vertOffset  [hit.geomId];
  
    const uint A = m_triIndices[(triOffset + hit.primId)*3 + 0];
    const uint B = m_triIndices[(triOffset + hit.primId)*3 + 1];
    const uint C = m_triIndices[(triOffset + hit.primId)*3 + 2];
  
    const vec3 A_norm = m_vNorm4f[A + vertOffset].xyz;
    const vec3 B_norm = m_vNorm4f[B + vertOffset].xyz;
    const vec3 C_norm = m_vNorm4f[C + vertOffset].xyz;

    const vec2 A_texc = m_vTexc2f[A + vertOffset];
    const vec2 B_texc = m_vTexc2f[B + vertOffset];
    const vec2 C_texc = m_vTexc2f[C + vertOffset];
      
    vec3 hitNorm = (1.0f - uv.x - uv.y)*A_norm + uv.y*B_norm + uv.x*C_norm;
    vec2 hitTexCoord = (1.0f - uv.x - uv.y)*A_texc + uv.y*B_texc + uv.x*C_texc;
  
    // transform surface point with matrix and flip normal if needed
    //
    hitNorm = normalize(mul3x3(m_normMatrices[hit.instId], hitNorm));
    const float flipNorm = dot(rayDir.xyz, hitNorm) > 0.001f ? -1.0f : 1.0f;
    hitNorm = flipNorm*hitNorm;
  
    rayFlags  = packMatId(currRayFlags, m_matIdByPrimId[m_matIdOffsets[hit.geomId] + hit.primId]);
    out_hit1  = vec4(hitPos, hitTexCoord.x); 
    out_hit2  = vec4(hitNorm, hitTexCoord.y); 
  }
  else
    rayFlags = currRayFlags | (RAY_FLAG_IS_DEAD | RAY_FLAG_OUT_OF_SCENE) ;

}

///////////////////////////////////////////////////////////////// subkernels here

void main()
{
  ///////////////////////////////////////////////////////////////// prolog
  const uint tid = uint(gl_GlobalInvocationID[0]); 
  ///////////////////////////////////////////////////////////////// prolog

  
  vec4 accumColor,  accumThoroughput;
  vec4 rayPosAndNear,  rayDirAndFar;
  RandomGen gen; 
  MisData   mis;
  uint      rayFlags;
  kernel_InitEyeRay2_m_packedXY(tid, 0, rayPosAndNear, rayDirAndFar, accumColor, accumThoroughput, gen, rayFlags);

  for(int depth = 0; uint(depth) < kgenArgs.a_maxDepth; depth++) 
  {
    vec4 shadeColor,  hitPart1,  hitPart2;
    kernel_RayTrace2(tid, rayPosAndNear, rayDirAndFar, hitPart1, hitPart2, rayFlags);
    if(isDeadRay(rayFlags))
      break;
    
    kernel_SampleLightSource(tid, rayPosAndNear, rayDirAndFar, hitPart1, hitPart2, rayFlags, 
                             gen, shadeColor);

    kernel_NextBounce(tid, uint(depth), hitPart1, hitPart2, shadeColor,
                      rayPosAndNear, rayDirAndFar, accumColor, accumThoroughput, gen, mis, rayFlags);
    if(isDeadRay(rayFlags))
      break;
  }

  kernel_ContributeToImage_m_packedXY_out_color(tid, accumColor, gen, 0, 0);
                           

}

