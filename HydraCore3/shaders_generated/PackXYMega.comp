#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require

#include "common_generated.h"

layout(binding = 0, set = 0) buffer data0 { uint m_packedXY[]; }; //
layout(binding = 1, set = 0) uniform sampler2D m_textures[]; //
layout(binding = 2, set = 0) buffer data2 { GLTFMaterial m_materials[]; }; //
layout(binding = 3, set = 0) buffer dataUBO { Integrator_UBO_Data ubo; };

uint packMatId(uint a_flags, uint a_matId) { return (a_flags & 0xFF000000) | (a_matId & 0x00FFFFFF); }

bool isDeadRay(uint a_flags) { return (a_flags & RAY_FLAG_IS_DEAD) != 0; }

BsdfSample MaterialSampleAndEval(int a_materialId, vec4 rands, vec3 v, vec3 n, vec2 tc) {
  const vec2 texCoordT = mulRows2x4(m_materials[a_materialId].row0[0], m_materials[a_materialId].row1[0], tc);
  const vec3 texColor = (texture(m_textures[ m_materials[a_materialId].texId[0] ], texCoordT)).xyz;

  const uint   type      = m_materials[a_materialId].brdfType;
  const vec3 color = m_materials[a_materialId].baseColor.xyz*texColor;
  const vec3 specular = m_materials[a_materialId].metalColor.xyz;
  const vec3 coat = m_materials[a_materialId].coatColor.xyz;
  const float  roughness = 1.0f - m_materials[a_materialId].glosiness;
  float  alpha           = m_materials[a_materialId].alpha;
  
  // TODO: read color     from texture
  // TODO: read roughness from texture
  // TODO: read alpha     from texture

  // TODO: check if glosiness in 1 (roughness is 0), use special case mirror brdf
  //if(roughness == 0.0f && type == BRDF_TYPE_GGX)
  //  type = BRDF_TYPE_MIRROR;

  BsdfSample res;
  switch(type)
  {
    case BRDF_TYPE_GLTF:
    case BRDF_TYPE_GGX:
    case BRDF_TYPE_LAMBERT:
    default:
    {
      const vec3 ggxDir = ggxSample(vec2(rands.x,rands.y), v, n, roughness);
      const float  ggxPdf = ggxEvalPDF (ggxDir, v, n, roughness); 
      const float  ggxVal = ggxEvalBSDF(ggxDir, v, n, roughness);
      
      const vec3 lambertDir = lambertSample(vec2(rands.x,rands.y), v, n);
      const float  lambertPdf = lambertEvalPDF(lambertDir, v, n);
      const float  lambertVal = lambertEvalBSDF(lambertDir, v, n);

      const vec3 h = normalize(v - ggxDir); // half vector.
    
      if(type == BRDF_TYPE_GGX)
        alpha = 1.0f;

      // (1) select between metal and dielectric via rands.z
      //
      float pdfSelect = 1.0f;
      if(rands.z < alpha) // select metall
      {
        pdfSelect *= alpha;
        const vec3 F = gltfConductorFresnel(specular, dot(h,v));
        res.direction = ggxDir;
        res.color     = ggxVal*F*alpha;
        res.pdf       = ggxPdf;
      }
      else                // select dielectric
      {
        pdfSelect *= 1.0f - alpha;
        
        // (2) now select between specular and diffise via rands.w
        //
        float fDielectric = gltfFresnelMix2(dot(h,v));
        if(type == BRDF_TYPE_LAMBERT)
          fDielectric = 0.0f;

        if(rands.w < fDielectric) // specular
        {
          pdfSelect *= fDielectric;
          res.direction = ggxDir;
          res.color     = ggxVal*coat*fDielectric*(1.0f - alpha);
          res.pdf       = ggxPdf;
        } 
        else
        {
          pdfSelect *= (1.0f-fDielectric); // lambert
          res.direction = lambertDir;
          res.color     = lambertVal*color*(1.0f-fDielectric)*(1.0f - alpha);
          res.pdf       = lambertPdf;
        }
      }
      
      res.pdf *= pdfSelect;
      res.flags = int(RAY_FLAG_HAS_NON_SPEC);
    }
    break;
    case BRDF_TYPE_MIRROR:
    {
      res.direction = reflect(v, n);
      // BSDF is multiplied (outside) by cosThetaOut.
      // For mirrors this shouldn't be done, so we pre-divide here instead.
      //
      const float cosThetaOut = dot(res.direction, n);
      res.color     = specular*(1.0f/max(cosThetaOut, 1e-6f));
      res.pdf       = 1.0f;
      res.flags     = 0;
    }
    break;
  }

  return res;
}

float LightEvalPDF(int a_lightId, vec3 illuminationPoint, vec3 ray_dir, in SurfaceHit pSurfaceHit) {
  const vec3 lpos = pSurfaceHit.pos;
  const vec3 lnorm = pSurfaceHit.norm;
  const float hitDist = length(illuminationPoint - lpos);
  const float pdfA    = 1.0f / (4.0f*ubo.m_light.size.x*ubo.m_light.size.y);
  const float cosVal  = max(dot(ray_dir, -1.0f*lnorm), 0.0f);
  return PdfAtoW(pdfA, hitDist, cosVal);
}

float LightPdfSelectRev(int a_lightId) { 
  return 1.0f; 
}

uint extractMatId(uint a_flags) { return (a_flags & 0x00FFFFFF); }

bool hasNonSpecular(uint a_flags) { return (a_flags & RAY_FLAG_HAS_NON_SPEC) != 0; }

BsdfEval MaterialEval(int a_materialId, vec3 l, vec3 v, vec3 n, vec2 tc) {
  const vec2 texCoordT = mulRows2x4(m_materials[a_materialId].row0[0], m_materials[a_materialId].row1[0], tc);
  const vec3 texColor = (texture(m_textures[ m_materials[a_materialId].texId[0] ], texCoordT)).xyz;

  const uint type       = m_materials[a_materialId].brdfType;
  const vec3 color = m_materials[a_materialId].baseColor.xyz*texColor;
  const vec3 specular = m_materials[a_materialId].metalColor.xyz;
  const vec3 coat = m_materials[a_materialId].coatColor.xyz;
  const float roughness = 1.0f - m_materials[a_materialId].glosiness;
        float  alpha    = m_materials[a_materialId].alpha;

  // TODO: read color     from texture
  // TODO: read roughness from texture
  // TODO: read alpha     from texture
 
  // TODO: check if glosiness in 1 (roughness is 0), use special case mirror brdf
  //if(roughness == 0.0f && type == BRDF_TYPE_GGX)
  //  type = BRDF_TYPE_MIRROR;


  BsdfEval res;
  switch(type)
  {
    case BRDF_TYPE_GLTF:
    case BRDF_TYPE_GGX:
    case BRDF_TYPE_LAMBERT:
    default:
    {
      if(type == BRDF_TYPE_GGX)
        alpha = 1.0f;
        
      const float ggxVal = ggxEvalBSDF(l, v, n, roughness);
      const float ggxPdf = ggxEvalPDF (l, v, n, roughness);
      
      const float lambertVal = lambertEvalBSDF(l, v, n);
      const float lambertPdf = lambertEvalPDF (l, v, n);
      
      const vec3 h = normalize(v + l);
      const vec3 F = gltfConductorFresnel(specular, dot(h,v));

      const vec3 specularColor = ggxVal*F;                  // (1) eval metal and (same) specular component
      float  fDielectric         = gltfFresnelMix2(dot(h,v)); // (2) eval dielectric component
      if(type == BRDF_TYPE_LAMBERT)
        fDielectric = 0.0f;
      const float  dielectricPdf = (1.0f-fDielectric)*lambertPdf       + fDielectric*ggxPdf;
      const vec3 dielectricVal = (1.0f-fDielectric)*lambertVal*color + fDielectric*ggxVal*coat;

      res.color = alpha*specularColor + (1.0f - alpha)*dielectricVal; // (3) accumulate final color and pdf
      res.pdf   = alpha*ggxPdf        + (1.0f - alpha)*dielectricPdf; // (3) accumulate final color and pdf
    }
    break;
    case BRDF_TYPE_MIRROR:
    {
      res.color = vec3(0,0,0);
      res.pdf   = 0.0f;
    }
    break;
  }
  return res;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout( push_constant ) uniform kernelArgs
{
  uint iNumElementsX; 
  uint iNumElementsY; 
  uint iNumElementsZ; 
  uint tFlagsMask;    
} kgenArgs;

///////////////////////////////////////////////////////////////// subkernels here
void kernel_PackXY_m_packedXY(uint tidX, uint tidY, uint out_pakedXYOffset) 
{
  
  const uint inBlockIdX = tidX % 8; // 8x8 blocks
  const uint inBlockIdY = tidY % 8; // 8x8 blocks
 
  const uint localIndex = inBlockIdY*8 + inBlockIdX;
  const uint wBlocks    = ubo.m_winWidth/8;

  const uint blockX     = tidX/8;
  const uint blockY     = tidY/8;
  const uint offset     = (blockX + blockY*wBlocks)*8*8 + localIndex;

  m_packedXY[offset + out_pakedXYOffset] = ((tidY << 16) & 0xFFFF0000) | (tidX & 0x0000FFFF);

}

///////////////////////////////////////////////////////////////// subkernels here

void main()
{
  ///////////////////////////////////////////////////////////////// prolog
  const uint tidX = uint(gl_GlobalInvocationID[0]); 
  const uint tidY = uint(gl_GlobalInvocationID[1]); 
  ///////////////////////////////////////////////////////////////// prolog

  
  kernel_PackXY_m_packedXY(tidX, tidY, 0);

}

